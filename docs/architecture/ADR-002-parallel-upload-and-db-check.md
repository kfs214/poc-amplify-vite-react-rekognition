# ADR-002: アップロードとDB確認の並行処理

## ステータス
採用 (2025-10-28)

## コンテキスト
画面Aでプロフィール画像をアップロードした後、既存のLiveness画像があるかをDB確認し、新規/更新フローを分岐する必要がある。

ユーザー体験を最適化するため、不必要な待ち時間を削減したい。

## 検討した選択肢

### 選択肢1: 逐次処理（シンプル）
```typescript
1. S3アップロード完了を待つ（500ms-2s）
2. その後DB確認（100-300ms）
3. 分岐判定
```

**メリット**: 実装が最もシンプル
**デメリット**: ユーザーが両方の処理を待つ（合計600ms-2.3s）

### 選択肢2: 並行処理（Promise.all）（採用）
```typescript
Promise.all([
  uploadData(...),              // S3アップロード
  client.models.UserLivenessInfo.get(...)  // DB確認
])
```

**メリット**: 
- DB確認がアップロード中に完了するため、体感50%短縮
- 実装コストは+10行程度
- エラーハンドリングも比較的シンプル

**デメリット**: 
- やや複雑（Promise.allの理解が必要）
- 両方のエラーを適切にハンドリングする必要がある

### 選択肢3: 遅延アップロード（超最適化）
```typescript
1. DB確認のみ（100-300ms）
2. 分岐判定
3-a. 新規フロー: Liveness中にバックグラウンドアップロード
3-b. 更新フロー: Result遷移前にアップロード
```

**メリット**: 理論上最速（DB確認の100-300msのみ）
**デメリット**: 
- 実装が複雑（+50行以上）
- ファイルオブジェクトをContext/Stateで持ち回る必要
- バックグラウンドアップロードの状態管理が必要
- エラーハンドリングが複雑（Liveness成功したのにアップロード失敗など）
- PoCとして過剰設計

## 決定
**選択肢2: 並行処理（Promise.all）** を採用

## 理由
- PoCのゴールは「Look & Feel」の体験
- UX改善効果が大きい（体感50%短縮）
- 実装コストが低い（10-15行の追加）
- 選択肢3はPoCとして過剰設計
- デザイナーが「ぐるぐるが短い！」と感じられる

## 実装例
```typescript
const [uploadResult, dbResult] = await Promise.all([
  uploadData({ 
    path: `profileImages/${userId}/${Date.now()}.jpg`, 
    data: file 
  }),
  client.models.UserLivenessInfo.get({ id: userId })
]);

// dbResultで分岐判定
if (!dbResult?.data?.livenessImageKey) {
  navigate('/liveness'); // 新規登録フロー
} else {
  navigate('/result');   // 更新フロー
}
```

## 影響
- タスク7.2とタスク7.3の実装が統合される
- `Promise.all`を使用したエラーハンドリングが必要
- デザイナーがストレスなく体験できる
- 体感的なローディング時間が約50%短縮

## 測定結果（想定）
- 選択肢1: 600ms-2300ms
- 選択肢2: 500ms-2000ms（DB確認はアップロード中に完了）
- 選択肢3: 100-300ms（ただし実装複雑性が高い）

## 参考
- MASTER_PLAN.md タスク7.2-7.3
- スレッドでの議論: "お客さんを一番待たせない方法として...サクッとできそうならやってもいい"

