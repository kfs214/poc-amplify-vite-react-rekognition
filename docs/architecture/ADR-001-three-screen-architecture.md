# ADR-001: 3画面構成とモックヘッダー

## ステータス
採用 (2025-10-28)

## コンテキスト
顔認証PoCアプリを構築する際、本番環境では以下の3つの実行コンテキストが存在する：
1. モバイルアプリ本体（React Native）- プロフィール写真アップロード
2. アプリ内ブラウザ（WebView）- Livenessチェック
3. モバイルアプリ本体 - 結果表示

デザイナーやビジネスサイドに「Look & Feel」を体験してもらうため、これらの違いを可視化する必要がある。

## 検討した選択肢

### 選択肢1: 単一画面でシームレスな体験
すべてを1つの画面で実装し、実行コンテキストの違いを表現しない。

**メリット**: 実装が最もシンプル
**デメリット**: 
- 本番環境との違いが伝わらない
- デザイナーが実際のUXを想像しにくい

### 選択肢2: 別タブ/別ウィンドウで実装
各コンテキストを実際に別タブで開く。

**メリット**: より本番環境に近い
**デメリット**: 
- 開発コストが高い
- PoC体験時の操作が煩雑
- タブ間の状態管理が複雑

### 選択肢3: 3画面構成 + モックヘッダー（採用）
単一アプリ内で3画面を実装し、各画面にモックヘッダーを表示：
- 「【アプリ画面 (モック)】」
- 「【アプリ内ブラウザ (モック)】」

**メリット**:
- 実装コストが低い
- デザイナーに「今どのコンテキストか」が一目で分かる
- 画面遷移がスムーズ
- PoCとして適切なバランス

**デメリット**: 
- 完全に本番環境を再現しているわけではない

## 決定
**選択肢3: 3画面構成 + モックヘッダー** を採用

## 理由
- PoCの目的は「Look & Feel」の体験であり、完全な実装ではない
- モックヘッダーにより、デザイナーが実行コンテキストを理解できる
- 開発コストをかけずに、UXのリアリティを向上できる
- 選択肢2は過剰設計で、PoC体験を複雑にしてしまう

## 実装
- `src/screens/UploadScreen.tsx`: 画面A（アプリ画面）
- `src/screens/LivenessScreen.tsx`: 画面B（アプリ内ブラウザ）
- `src/screens/ResultScreen.tsx`: 画面C（アプリ画面）
- 各画面に視覚的に区別できるヘッダーを配置

## 影響
- デザイナーやステークホルダーが実行コンテキストの違いを理解しやすくなる
- 3画面のルーティング実装が必要（react-router-dom）
- 画面間のデータ連携（Context API）が必要

## 参考
- MASTER_PLAN.md マイルストーン1
- ユーザーからの設計思想: "デザイナーに「今、どのコンテキストの画面を触っているか」を視覚的に明示するため"

